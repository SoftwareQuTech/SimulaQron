
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Overview &#8212; SimulaQron 1.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Getting started" href="GettingStarted.html" />
    <link rel="prev" title="SimulaQron Documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="GettingStarted.html" title="Getting started"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SimulaQron Documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SimulaQron 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Overview</a><ul>
<li><a class="reference internal" href="#programming-simulaqron">Programming SimulaQron</a></li>
<li><a class="reference internal" href="#how-simulaqron-works-internally">How SimulaQron works internally</a><ul>
<li><a class="reference internal" href="#virtual-quantum-nodes">Virtual quantum nodes</a></li>
<li><a class="reference internal" href="#the-local-client-engine">The local client engine</a></li>
</ul>
</li>
<li><a class="reference internal" href="#report-bugs-and-contribute">Report bugs and contribute</a><ul>
<li><a class="reference internal" href="#bugs-and-feature-requests">Bugs and feature requests</a></li>
<li><a class="reference internal" href="#contribute">Contribute</a></li>
<li><a class="reference internal" href="#automated-tests">Automated tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">SimulaQron Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="GettingStarted.html"
                        title="next chapter">Getting started</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Overview.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="programming-simulaqron">
<h2>Programming SimulaQron<a class="headerlink" href="#programming-simulaqron" title="Permalink to this headline">¶</a></h2>
<p>There are two ways to program SimulaQron to run applications. The first is to use SimulaQron’s native interface via <a class="reference external" href="https://twistedmatrix.com/">Twisted</a> Perspective Broker. This interface is specific to Python, and not (easily) accessible from other languages. We will call this interface SimulaQron’s native interface throughout. While you may play with simple applications this way, the main purpose of this interface is to allow the development of higher protocol layers and abstractions which will ultimately be used to program quantum networks.
In the light of the alternate interface below it may appear inefficient to export an intermediary interface. However, the purpose of SimulaQron is precisely to explore and play with higher layer abstractions on top of any hardware, or its simulated version, SimulaQron. As such it is best to think of SimulaQron as a piece of simulated hardware with its own native interface, which we may first abstract into a higher level command language for programming. Examples of how to program SimulaQron in native mode can be found in <a class="reference internal" href="ExamplesDirect.html"><span class="doc">Programming via SimulaQron’s native Python Twisted Interface (specific to SimulaQron)</span></a>.</p>
<p>The second way to run applications is via a higher level interface bundled with SimulaQron, called the classical-quantum combiner (CQC) interface. This interface is universally accessible from any language. It comes with a C and Python library, where the Python CQC is definitely the best place to get started if you have never programmed SimulaQron before. An evolved version of a C library and interface is targeted to be available on the planned 2020 quantum internet demonstrator connecting several Dutch cities. If you want your applications to later use real quantum hardware more easily instead of SimulaQron, then this is the interface to use. Internally, the CQC included in this package, uses SimulaQron’s native interface from above in place of real quantum hardware. Examples of how to program using the CQC can be found in <a class="reference internal" href="ExamplesNodeOS.html"><span class="doc">Programming via the Classical-Quantum Combiner Interface</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The C library is currently out of date but is being updated. See corresponding <a class="reference external" href="https://github.com/SoftwareQuTech/SimulaQron/issues/61">issue</a> at GitHub.</p>
</div>
<a class="reference internal image-reference" href="_images/CQC_schematic_v3.png"><img alt="Programming SimulaQrons Interfaces" class="align-center" src="_images/CQC_schematic_v3.png" style="width: 400px;" /></a>
<p>Practically, SimulaQron’s Backend is a server process running on each local classical computer (or on a single classical computer), emulating quantum hardware. The backend can be programmed directly using Twisted PB aka native mode. For clarity, not efficiency, the CQC Backend is a separate server process, which connects to the SimulaQron backend using Twisted PB. It accepts incoming connections, and using a general packet format can be programmed using any programming language. Libraries for C and Python are provided. If you are starting out, programming in the Python CQC library is by far the easiest way to get going! Further information about the Python library can be found in <a class="reference internal" href="PythonLib.html"><span class="doc">Using the Python library</span></a>: and explicit examples using this library in <a class="reference internal" href="ExamplespythonLib.html"><span class="doc">Examples using the python library</span></a>:.</p>
</div>
<div class="section" id="how-simulaqron-works-internally">
<h2>How SimulaQron works internally<a class="headerlink" href="#how-simulaqron-works-internally" title="Permalink to this headline">¶</a></h2>
<p>Let us here briefly sketch how the SimulaQron backend works internally. Further details can be found in our <a class="reference external" href="http://iopscience.iop.org/article/10.1088/2058-9565/aad56e">paper</a>.
The simulator consists of two parts and has a relatively modular design:</p>
<div class="section" id="virtual-quantum-nodes">
<h3>Virtual quantum nodes<a class="headerlink" href="#virtual-quantum-nodes" title="Permalink to this headline">¶</a></h3>
<p>A virtual quantum node is a server program running on a particular computer that pretends to be quantum hardware, simulating qubits and quantum communication.
That is, you may think of these nodes as fake hardware programmable directly via SimulaQron’s native interface. Each node presents
a number of virtual qubits for you to use. These virtual qubits would correspond to the physical qubits
available at this node, would this be a real physical implementation of the quantum network node. By connecting to the virtual quantum node server, a
client program that depends on using quantum hardware, may manipulate these qubits as if they were local physical qubit and also
instruct to send them to remote nodes.
The virtual quantum node servers are identified
by their common names (eg Alice, Bob, Charlie), and amongst themselves connect classically to form a virtual simulation
network as a backend.</p>
<p>An important internal element in SimulaQron is the distinction between virtual qubits and simulated qubits. Virtual qubits
are the qubits as they would be present in real quantum hardware. A virtual qubit is local to each virtual quantum node server
and may be manipulated there. Each virtual qubit is simulated somewhere, by a simulated qubit. Importantly, this simulated qubit
may be located at a different simulating node than the node holding the corresponding virtual qubit.
To see why this is necessary, note that
entangled qubits cannot be locally represented by any form of classical information (hence
the quantum advantage of entanglement in the first place!). As such, if two (or more) virtual nodes share
qubits which are somehow entangled with each other, then these qubits will actually need to be simulated
at just one of these nodes. That is, they appear to be virtually local (as if they were real physical
qubits), yet they are actually simulated at just one of the network nodes. As you might imagine,
this also means that if we want to perform an entangling gate between two qubits which are virtually
local, but actually simulated in two different backend quantum registers, then a merge of these
registers is required before the entangling gate can be executed. This is all handled transparently
by the backend provided here. For programming network applications using SimulaQron you will not need to
deal with this backend simulation.</p>
<p>Nevertheless, as a guide to the backend, it consists of three essential components:</p>
<ul class="simple">
<li>quantumEngine - the one used here is implemented as simpleEngine in crudeSimulator.py which uses <a class="reference external" href="http://qutip.org/">QuTip</a> as a backend. This corresponds to one quantum register full of qubits across which gates can be performed. Should you wish to use a different backend, you may wish to add a different engine.</li>
<li>simulatedQubit - for each qubit simulated in that register, there is a simQubit object. This is local to each node. It exports remote method calls. These methods are only called by the virtual node network itself: when a virtual node discovers the qubit is actually simulated remotely, it passes on this call by calling the relevant method on the remote qubit object.</li>
<li>virtualQubit - this is the object representing a virtually local qubit. This carries information about the remote simulating qubit. These virtualQubit objects can in turn be accessed by the clients who can access these virtual qubits as if they were real local physical qubits without having to know where they are actually simulated. That is, the client obtains a pointer to the relevant virtual qubit object on which it can perform operations directly.</li>
<li>virtualNode - this is the local virtual node which accepts requests to get a virtual qubit object, send qubits to other nodes, read out the state of qubits, perform gates etc.</li>
<li>backEnd - starts up the virtual node backend</li>
</ul>
<a class="reference internal image-reference" href="_images/simulated_virtualQubits_v7.png"><img alt="Virtual and simulated qubit" class="align-center" src="_images/simulated_virtualQubits_v7.png" style="width: 550px;" /></a>
</div>
<div class="section" id="the-local-client-engine">
<h3>The local client engine<a class="headerlink" href="#the-local-client-engine" title="Permalink to this headline">¶</a></h3>
<p>The second part is a framework for writing applications that use the virtually simulated quantum
network. Such an application needs to connect locally to the virtual quantum node server simulating the underlying hardware (for programming
in native mode), or to the CQC interface. It is up to these applications to exchange any classical communication required to execute the protocol.</p>
</div>
</div>
<div class="section" id="report-bugs-and-contribute">
<h2>Report bugs and contribute<a class="headerlink" href="#report-bugs-and-contribute" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bugs-and-feature-requests">
<h3>Bugs and feature requests<a class="headerlink" href="#bugs-and-feature-requests" title="Permalink to this headline">¶</a></h3>
<p>For bugs, feature requests, suggestions or other general questions please use GitHubs issue tracker in the repository (located under ‘Issues’ on the main page of the repository).
Please start your message with specifying one of the four labels below for easier handling of issues, for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="p">:</span> <span class="n">bug</span>

<span class="n">There</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">bug</span> <span class="n">when</span> <span class="n">applying</span> <span class="n">the</span> <span class="n">gate</span><span class="o">...</span>
</pre></div>
</div>
<p>Always provide enough information to assess the issue and separate different issues into different messages.</p>
<ul class="simple">
<li><em>bug</em>: This is for bugs that are encountered. Please provide a way to reproduce the bug, preferably with a minimal example, and explain what goes wrong.</li>
<li><em>feature request</em>: Is there a feature that you think should be provided? Explain the details of the feature and why you think this should be implemented.</li>
<li><em>help wanted</em>: If there is something you having trouble with but which is not necessarily a bug. Also use this for other general questions.</li>
<li><em>suggestions</em>: If you have suggestions on how to improve the features already existing. Be clear on what exactly you think should be improved and explain why.</li>
</ul>
</div>
<div class="section" id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this headline">¶</a></h3>
<p>If you would like to contribute with your own code to fix a bug or add an additional feature, this is most welcomed.
Please then make a pull request on GitHub, which will be reviewed before approval.
For contributing use the <em>Develop</em>-branch.
Please make sure you run the automated tests below before submitting any code.
The easiest way to proceed is to:</p>
<ol class="arabic simple">
<li>Fork the repository at the <em>Develop</em>-branch.</li>
<li>Make the changes and commit these to your forked branch.</li>
<li>Make a pull request between your branch and the <em>Develop</em>-branch. Also provide a message which explains the changes and/or additions you have made.</li>
</ol>
</div>
<div class="section" id="automated-tests">
<h3>Automated tests<a class="headerlink" href="#automated-tests" title="Permalink to this headline">¶</a></h3>
<p>There are number of automated tests that test many (but not all) of the features of SimulaQron and the CQC interface.
See <a class="reference internal" href="GettingStarted.html"><span class="doc">Getting started</span></a> for how to run these.
Some of the automated tests use quantum tomography and are thus inherently probabilistic.
Therefore if you see that one of these fails, you can try to run the test again and see if it is consistent.
If the tests are to slow on your computer you can also run the short version, which skips the quantum tomography tests.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="GettingStarted.html" title="Getting started"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SimulaQron Documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SimulaQron 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Stephanie Wehner and Axel Dahlberg.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.4.
    </div>
  </body>
</html>